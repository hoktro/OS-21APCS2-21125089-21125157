1. Looking at the backtrace output, which function called syscall?

(gdb) backtrace
#0 syscall () at kernel/syscall.c:137
#1 0x0000000080001d72 in usertrap () at kernel/trap.c:67
#2 0x0505050505050505 in ?? ()

Conclusion: syscall function was called by usertrap function in kernel/trap

2. What is the vale of p->trapframe->a7 and what does that value represent?

(gdb) p /x p->trapframe->a7
$2 = 0x7

Conclusion: 0x7 is defined to be the index for SYS_exec which prepare for the syscall exec in the following code.

3. What was the previous mode that the CPU was in?

(gdb) p /x $sstatus
$3 = 0x22

Conclusion: The SPP-bit(8th bit) of the sstatus indicates the previledge level at which hart was execution before entering supervisor mode. In this case, SPP-bit is 0 which means the previous mode is user mode.

4. Write down the assembly instruction the kernel is panicing at. Which register correponds to the variable num?

80002052:	00002683          	lw	a3,0(zero) # 0 <_entry-0x80000000>

Conclusion: variable num corresponds to register a3.

5. Why does the kernel crash?
Conclusion: The address 0 is not mapped in the kernel's space which is supported by the value of $scause "page fault caused by a read".

6. What is the name of the binary that was running when the kernel paniced? What is its process id (pid)?

(gdb) p p->name
$1 = "initcode\000\000\000\000\000\000\000"

Conclusion: The name of the binary that was running when the kernel paniced is initcode.

(gdb) p p->pid
$2 = 1

Conclusion: Process id at the time is 1.